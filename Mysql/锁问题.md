##锁问题
****
### # 锁是计算机协调多个进程或线程并发访问某一资源的机制
* 在数据库中，除传统的计算资源 (如 CPU、RAM、I/O 等)的争用以外，数据也是一种供许多用户共享的资源
* MySQL的锁机制比较简单，其最显著的特点是不同的存储引擎支持不 同的锁机制。比如，MyISAM和MEMORY存储引擎采用的是表级锁(table-level locking);BDB 存储引擎采用的是页面锁(page-level locking)，但也支持表级锁;InnoDB存储引擎既支持行 级锁(row-level locking)，也支持表级锁，但默认情况下是采用行级锁。
* MySQL这3种锁的特性可大致归纳如下。
	* 表级锁:开销小，加锁快;不会出现死锁;锁定粒度大，发生锁冲突的概率最高,并发
度最低。
	* 行级锁:开销大，加锁慢;会出现死锁;锁定粒度最小，发生锁冲突的概率最低,并发 度也最高。
	* 页面锁:开销和加锁时间界于表锁和行锁之间;会出现死锁;锁定粒度界于表锁和行锁 之间，并发度一般。

* InnoDB 与 MyISAM 的最大不同有两点:一是支持事务(TRANSACTION);二是采用 了行级锁

### # InnoDB
* 事务是由一组 SQL 语句组成的逻辑处理单元
* 事务具有以下 4 个属性，通常简称为事务的 ACID 属性。
	* 原子性(Atomicity):事务是一个原子操作单元，其对数据的修改，要么全都执行， 要么全都不执行。
	* 一致性(Consistent):在事务开始和完成时，数据都必须保持一致状态。这意味着 所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性;事务结束时， 所有的内部数据结构(如 B 树索引或双向链表)也都必须是正确的。
	* 隔离性(Isolation):数据库系统提供一定的隔离机制，保证事务在不受外部并发操 作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见 的，反之亦然。
	* 持久性(Durable):事务完成之后，它对于数据的修改是永久性的，即使出现系统 故障也能够保持。

* 相对于串行处理来说，并发事务处理能大大增加数据库资源的利用率，提高数据库系统的事 务吞吐量，从而可以支持更多的用户。但并发事务处理也会带来一些问题，主要包括以下几 种情况。
	* 更新丢失(Lost Update):当两个或多个事务选择同一行，然后基于最初选定的 值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题 --最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一 文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这 样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖另一个编辑人员所做 的更改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同 一文件，则可避免此问题。
	* 脏读(Dirty Reads):一个事务正在对一条记录做修改，在这个事务完成并提交 前，这条记录的数据就处于不一致状态;这时，另一个事务也来读取同一条记录， 如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就 会产生未提交的数据依赖关系。这种现象被形象地叫做"脏读"。
	* 不可重复读(Non-Repeatable Reads):一个事务在读取某些数据后的某个时间， 再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已 经被删除了!这种现象就叫做“不可重复读”。
	* 幻读(Phantom Reads):一个事务按相同的查询条件重新读取以前检索过的数据， 却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。
* “脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一 定的事务隔离机制来解决。数据库实现事务隔离的方式，基本上可分为以下两种。
	*  一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。
	*  另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快 照(Snapshot)，并用这个快照来提供一定级别(语句级或事务级)的一致性读取。 从用户的角度来看，好象是数据库可以提供同一数据的多个版本，因此，这种技 术叫做数据多版本并发控制(MultiVersion Concurrency Control，简称 MVCC 或
MCC)，也经常称为多版本数据库。

> 注意：`数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上 就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的`

* mysql> show status like 'innodb_row_lock%'; //检查 InnoDB_row_lock 状态变量来分析系统上的行锁的争夺情况

> 

		+-------------------------------+-------+
		| Variable_name                 | Value |
		+-------------------------------+-------+
		| Innodb_row_lock_current_waits | 0     |
		| Innodb_row_lock_time          | 20405 |
		| Innodb_row_lock_time_avg      | 6801  |
		| Innodb_row_lock_time_max      | 17334 |
		| Innodb_row_lock_waits         | 3     |
		+-------------------------------+-------+
		5 rows in set (0.00 sec)

### #InnoDB 的行锁模式及加锁方法
* InnoDB 实现了以下两种类型的行锁。
	* 共享锁(S):允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
	* 排他锁(X):允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享
读锁和排他写锁。

* InnoDB 还有两种内部使用的意向锁(Intention Locks)，这两种意向锁都是表锁。
	* 意向共享锁(IS):事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前
必须先取得该表的 IS 锁。
	* 意向排他锁(IX):事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前
必须先取得该表的 IX 锁。

* 意向锁是 InnoDB 自动加的，不需用户干预。对于 UPDATE、DELETE 和 INSERT 语句，InnoDB 会自动给涉及数据集加排他锁(X);对于普通 SELECT 语句，InnoDB 不会加任何锁;事务可 以通过以下语句显示给记录集加共享锁或排他锁。
	* 共享锁(S):SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。
	* 排他锁(X):SELECT * FROM table_name WHERE ... FOR UPDATE。
* mysql> show variables like 'autocommit'; //查看当前autocommit

> 
	+---------------+-------+
	| Variable_name | Value |
	+---------------+-------+
	| autocommit    | ON    |
	+---------------+-------+
	1 row in set (0.00 sec)
* set autocommit = 0; //OFF 
* set autocommit = 1;//ON

* 在获得共享锁 （...LOCK IN SHARE MODE）时，主要用在需要数据依存关系时来确认某行记 录是否存在
	* 在某一用户获得共享锁的情况下，其他用户对该条记录执行 更新 或者 删除操作的时候，会进入锁等待
	* 其他用户也可以获取共享锁去读取数据，仅用于读取数据
	* 当一方已经进入锁等待状态时，另一用户再次去执行 更新 或者 删除则会导致死锁
	* 等待状态在 对方释放共享锁的时候(commit 或者 autocommit 或者 一方死锁导致释放)，变为执行

* 在获得排它锁（SELECT...FOR UPDATE）时
	* 其他用户可以执行查询动作，但是该用户也想获取排他锁的时候会进入锁等待，等待一用户将锁释放。
* InnoDB 行锁是通过给索引上的索引项加锁来实现的，Oracle是通过在数据块中对相应数据行加锁来实现的
> `也就意味着:只有通过 索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁!，这一点他妈的特别重要，不注意会导致大量的锁冲突`
	* 由于 MySQL 的行锁是针对索引加的锁，不是针对记录加的锁，所以虽然是访问不同行 的记录，但是如果是使用相同的索引键，是会出现锁冲突的。应用设计的时候要注意这一点。
	* 查询的时候，只要通过该索引查询到的所有记录，都会被加锁。
	* 即便在条件中使用了索引字段，但是否使用索引来检索数据是由 MySQL 通过判断不同 执行计划的代价来决定的，如果 MySQL 认为全表扫描效率更高，比如对一些很小的表，它 就不会使用索引，这种情况下 InnoDB 将使用表锁，而不是行锁。因此，在分析锁冲突时， 别忘了检查 SQL 的执行计划，以确认是否真正使用了索引。（explain）
	* 检索值的数据类型与索引字段不同，虽然 MySQL 能够进行数据类型 转换，但却不会使用索引

* 间隙锁(Next-Key 锁)
	* 当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB 会给符合条 件的已有数据记录的索引项加锁;对于键值在条件范围内但并不存在的记录，叫做“间隙 (GAP)”，InnoDB 也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁(Next-Key 锁)。
	* InnoDB 使用间隙锁的目的，一方面是为了防止幻读，以满足相关隔离级别的要求，对于上 面的例子，要是不使用间隙锁，如果其他事务插入了 empid 大于 100 的任何记录，那么本 事务如果再次执行上述语句，就会发生幻读;另外一方面，是为了满足其恢复和复制的需要。 有关其恢复和复制对锁机制的影响，以及不同隔离级别下 InnoDB 使用间隙锁的情况
	* 在使用范围条件检索并锁定记录时，InnoDB 这种加锁机制会阻塞符合条件范围内 键值的并发插入，这往往会造成严重的锁等待。因此，在实际应用开发中，尤其是并发插入 比较多的应用，我们要尽量优化业务逻辑，尽量使用相等条件来访问更新数据，避免使用范 围条件。
	* InnoDB 除了通过范围条件加锁时使用间隙锁外，如果使用相等条件请 求给一个不存在的记录加锁，InnoDB 也会使用间隙锁!

* **恢复和复制的需要，对 InnoDB 锁机制的影响：MySQL 通过 BINLOG 录执行成功的 INSERT、UPDATE、DELETE 等更新数据的 SQL 语句，并由 此实现 MySQL 数据库的恢复和主从复制(可以参见本书“管理篇”的介绍)。MySQL 的恢复 机制(复制其实就是在 Slave Mysql 不断做基于 BINLOG 的恢复)有以下特点。**
	* 一是 MySQL 的恢复是 SQL 语句级的，也就是重新执行 BINLOG 中的 SQL 语句。这与 Oracle 数据库不同，Oracle 是基于数据库文件块的。
	* 二是 MySQL 的 Binlog 是按照事务提交的先后顺序记录的，恢复也是按这个顺序进行的。 这点也与 Oralce 不同，Oracle 是按照系统更新号(System Change Number，SCN)来恢 复数据的，每个事务开始时，Oracle 都会分配一个全局唯一的 SCN，SCN 的顺序与事务 开始的时间顺序是一致的。

>  `从上面两点可知，MySQL 的恢复机制要求:在一个事务未提交前，其他并发事务不能插入满足其锁定条件的任何记录，也就是不允许出现幻读，这已经超过了 ISO/ANSI SQL92“可重复读”隔离级别的要求，实际上是要求事务要串行化。这也是许多情况下， InnoDB 要用到间隙锁的原因，比如在用范围条件更新记录时，无论在 Read Commited 或 是 Repeatable Read 隔离级别下，InnoDB 都要使用间隙锁，但这并不是隔离级别要求的，`

* 循环锁等 待就是典型的死锁。
发生死锁后，InnoDB 一般都能自动检测到，并使一个事务释放锁并回退，另一个事务获得 锁，继续完成事务。但在涉及外部锁，或涉及表锁的情况下，InnoDB 并不能完全自动检测 到死锁，这需要通过设置锁等待超时参数 innodb_lock_wait_timeout 来解决

	* 需要说明的是， 这个参数并不是只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立 即获得所需的锁而挂起，会占用大量计算机资源，造成严重性能问题，甚至拖跨数据库。我 们通过设置合适的锁等待超时阈值，可以避免这种情况发生。
	* 通常来说，死锁都是应用设计的问题，通过调整业务流程、数据库对象设计、事务大小，以 及访问数据库的 SQL 语句，绝大部分死锁都可以避免。下面就通过实例来介绍几种避免死 锁的常用方法


































> 在此前消化消化，这两天学习的内容
> > sss> sss> sss> sss
> > 
> > 
> > 
> > > sss


> sss


> sss

> sss

> sss

> sss

> sss> sss

> sss

> sss


> sss

> sss

> sss

> sss

> sss> sss

> sss


		
		
		
