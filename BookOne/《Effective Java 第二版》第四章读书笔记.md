##类和接口
❶ *使类和成员的可访问性最小化*

* **模块之间通过API进行通信，一个模块不需要知道其他模块的内部工作情况，这个概念被称为信息隐藏，是软件设计的基本原则之一。**

> PS:它可以有效地解除组成系统的各模块之间的耦合关系，使这些模块可以独立地**` 开发 测试 优化 使用 理解 修改 `**使得这些模块可以并行开发，也减轻了维护的负担

* ***Java所提供的机制***

第一规则：访问控制(access control),尽可能地使每个类或者成员不被外界访问
**`顶层类 接口 注解 枚举 的访问修饰符：public 或者 不写（相当于protected包内的访问权限）`**
**`内部类访问修饰符：public protected private`**
**`接口或者注解 的内部接口 注解 只能用public修饰`**
**`成员、方法的修饰符：public protected private`**

❷ *在公有类中使用访问方法而非公有域*

* **在Java编程中严格要求使用 访问方法而不是 直接访问公有域，but 在Android中，公有域是提倡使用的，可使得方法数降低并提高程序性能，在此不详述**

❸ *使可变性最小化(线程安全)* --> 每个实例中包含信息必须在创建该实例的时候就提供，并在其生命周期内固定不变

	public class A{
		private final String a;
		private final int b;
		
		public A(String a ,int b){
			this.a = a;
			this.b = b;
		}
	}

`Java包含的不可变类（final）：String 基本类型的包装类 BigInteger BigDecimal` 
> 遵循下面五条规则

* 不要提供任何会修改对象状态的方法。
* 保证类不会被扩展，为防止子类化，一般做法是使类成为final，后面将讨论其他方法。
* 使所有的域都是final的，例如：内存模型。
* 使所有的域（代表属性或方法）都成为私有的，暴露出来的公开的域有可能被其他地方拿到其对象的引用，导致客户端直接修改这些对象。
* 确保对任何可变组件的互斥访问，类中的某一属性，如果是可变的，则确保该类的客户端无法获得指向这些对象的引用

> 不可变对象本质上是线程安全的

> 不可变的类可以提供一些静态工厂，把频繁使用的实例缓存起来

**`“不可变对象可以被自由地共享” 导致的结果是：永远也不需要进行保护性拷贝，因为这些拷贝始终等于原始对`** **`象，因此不需要也不应该为不可变的类提供clone方法或者拷贝构造器`**

**`不可变类真正唯一的缺点是：对每个不同的值都需要一个单独的对象，创建这种对象的代价可能很高`**

* **`解决方案：提供一个可变配套类，例如：String StringBuilder`**

> 保证类不会被扩展的第二种方法：
**`让类的所有构造器都变成私有的或者包级私有的，并添加公有的静态工厂来代替构造器`**

	public class Complex{
		private final double re;
		private final double im;
		
		private Complex(douboe re ,double im){
			this.re = re;
			this.im = im;
		}
		
		public statis Complex valueOf(double re, double im){
			return new Complex(re, im);
		}
	}
> 后续补充
	
❹ *复合优于继承*

❺ *要么为继承而设计，并提供文档说明，要么就禁止继承*

❻ *接口优于抽象类*

❼ *接口只用于定义类型*
	
	常量接口模式是对接口的不良使用
❽ *类层次优于标签类*

❾ *用函数对象表示策略*
	
	有些语言支持函数指针(function pointer)、代理(delegate)/lambda表达式(lambda expression)，
	或者支持类似的机制，允许程序把“调用特殊函数的能力” 存储起来并传递这种能力。这种机制同城用于允许函数
	的调用者通过传入第二个参数，来指定自己的行为。

	比较器 正是策略模式的一个例子
	
*  **简而言之，函数指针的主要用途就是实现侧落模式。为了在Java中实现这种模式，要申明一个接口来表示该策略，并且为每个具体策略申明一个实现了该接口的类。当一个具体策略只被使用一次时，通常使用匿名内部类来申明和实例化这个具体侧策略类。当一个具体的策略类是用来被设计为重复使用的时候，它的类通常就要被实现为私有的静态成员类，并通过公有的静态final域被导出，其类型为该策略接口**

❿ *优先考虑静态成员类*

* 嵌套类：是指被定义在另一个类的内部的类

> 存在的目的应该只是为它的外围类提供服务，如果嵌套类将来可能会用于其他的某个环境中，它就应该是顶层类。

* 嵌套类有四种：**`静态成员类(static member class)`**、**`非静态成员类(nonstatic memberclass)`**
、**`匿名类`**、**`局部类`**

> ***静态成员类***
	
	最简单的一种嵌套类，它可以访问外围类的所有成员，包括申明为私有的成员。静态成员类是外围类的一个静态成
	员，与其他静态成员一样，也遵守同样的可访问性规则。如果它被申明为私有的，它就只能在外围的内部才可以被
	访问

> ***非静态成员类***

> **PS :如果嵌套类的实例可以在它的外围类的实例之外独立存在，这个嵌套类就必须是静态成员类，要在没有外围实例的情况下，想创建非静态的实例是不可能的。（与外围类的生命周期一致）

	与静态成员类唯一的区别是，经他成员类的声明中包含修饰符static。尽管它们的语法非常相似，但是这两种嵌
	套类有很大的不同，费静态成员类的每个实例都隐含着与外围类的一个外围实例县相关联，在费静态成员类的实
	例方法内部，可以调用外围实例上的方法，或者利用修饰过的this构造获得外围实例的引用。
	
> ***匿名类*** 动态创建函数

	匿名类是不能有名字的类，它们不能被引用，只能在创建时用New语句来声明它们。匿名类的声明是在编译时进行
	的，实例化在运行时进行，这意味着for循环中的一个new语句会创建相同匿名类的几个实例，而不是创建几个不
	同匿名类的一个实例。
	
	匿名类的目的是在某个地方需要特殊的实现，因此在该处编写其实现，并获取它的实例，调用它的方法。不要在匿
	名内部类编写其他的方法，是不可见的。
	
	abstract class Person {
    	public abstract void eat();
	}
 
 	//使用的时候才去实现
	public class Demo {
    	public static void main(String[] args) {
        	Person p = new Person() {
            	public void eat() {
                	System.out.println("eat something");
            	}
        	};
        	p.eat();
    	}	
	}

	android example：
	public class Demo {
    	public static void main(String[] args) {
        	Runnable r = new Runnable() {
            	public void run() {
                	for (int i = 1; i <= 5; i++) {
                    	System.out.print(i + " ");
                	}
            	}
        	};
        	Thread t = new Thread(r);
        	t.start();
    	}
	}

> ***局部类***

	（1）局部内部类的定义和局部变量的定义一样，不用加限定符，其作用域是为本代码块。
	（2）它可以访问外部类的实例变量，也可以访问外部类的局部变量，但是外部类的局部变量必须为final的。
	（3）可以配合interface来使用来做到强制性的弱耦合。
	（4）在另外的一个类的中不可以创建局部内部类的实例，只能在局部内部类中来创建。
	
	public class Person(){
		private int age;
		public void run(){
			class Run{
			}
		}
	}
	
***`PS:` `如果成员类的每个实例都需要一个指向其外围实例的引用，就要把成员类做成非静态的，否则，就做成`***
***`静态的。假设这个嵌套属于一个方法内部，如果只需要在一个地方创建实例，并且已经有了一个预置的类型可以`***
***`说明这个类的特征，就要把它做成匿名类，否则，就做成局部类`***
	














	
	
	
	
	
	




